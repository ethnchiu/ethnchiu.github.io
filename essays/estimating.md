---
layout: essay
type: essay
title: "Estimating"
# All dates must be YYYY-MM-DD format!
date: 2025-12-13
published: true
labels:
  - Effort Estimation
  - IDPM
---

<img height="200px" src="../img/estimating/checklist.png" class="rounded float-end ps-4">

## I wonder how long this will take?

When I think about software engineering, a few things immediately come to mind: programming, teamwork, designing. Nowhere in there is effort estimation. But after learning about Issue Driven Project Management (IDPM) Effort Estimation and putting it into practice in developing [RIBows](https://ri-bows.vercel.app/), I've come to realize the importance of tracking the amount of time and effort spent when developing software. Earlier in the semester for ICS 314 we had WODs, which are essentially timed coding quizzes. The fact that these were timed allowed me to easily see what areas I was proficient in and what skills I needed to work on. My completion times for the WODs served as the historical basis for my effort estimates when developing RIBows.

# The benefits

Making estimates for how long an issue takes to resolve comes with multiple benefits. First, it helps with planning and organization. If you're accountable for an issue that is estimated to take an hour to finish, you'll know to leave yourself at least an hour before the due date to work on it. Second, it enables teams to more evenly distribute the workload. By having an estimate of how long each issue will take to resolve, the team can assign issues accordingly. Lastly, the evolution of your own personal estimates can be a nice way of tracking your own self-improvement and growth.

# In practice

For RIBows, my team tracked effort estimation by utilizing the Github Project Board. A link to our most recent milestone project board can be found [here](https://github.com/orgs/RI-Bows/projects/11). Personally, I tracked my times by noting my start and end time and then partitioning that duration into coding and non-coding time depending on how long I spent on both. I think this method was relatively accurate but, more importantly, practical since when I code I rapidly switch between actual coding and non-coding tasks like reading documentation and searching for solutions. In the future, it would be interesting to try using dedicated timing plugins or software to more accurately keep track of coding vs non-coding time.